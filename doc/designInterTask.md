# Intertask communication #

## Introduction ##

With our previous example, we know how to configure the ESP8266 as an access point. Next step I have in mind would be to start a TCP server and to wait for incoming connection requests. One way to implement this would be to put all required code in the same thread. But usually, that's better to separate functions: one task for Wi-Fi handling and one task for TCP server handling would allow for easier maintenance of the code.

But when there are more then one task in an application, it is usually required to let some of them exchange some information.

## Queues ##

FreeRTOS, on which Espressif RTOS SDK is based, offers the [*queue* structure](http://www.freertos.org/Embedded-RTOS-Queues.html) to implement intertask communications.

We'll use queues this way:

* every task owns a queue, used to receive messages.
* a message is made of an identifier and some (optional) data.
* a task is blocked on its queue until a new message is received. The task processes the received message, and then blocks again until next message is received.
* writing a message to a task's queue is non-blocking.
* every event that a task has to handle, including its own internal events, is delivered to the task's queue.

## Finite state automaton ##

One way to code a task is to use the finite state automaton pattern. In a few words:

* the task can be in different states. Number of such states is finite.
* at one given time, the task is in one and only one state.
* the only way to make the task transitioning from one state to another one is to send it an event. Events are serialized: at one given time, only one event is received.
* the new state depends on previous state and received event.

Refer to [this article](http://www.monblocnotes.com/node/1906), for more information about this *cooperating components* pattern.

## Example ##

Our *interTask* code sample implements two tasks. 

The first one is so simple that it does not implement a finite state automaton. It uses a timer to generate a message on a periodic basis.

The second task receives messages generated by the first one. At starting time, it is in an idle state, and starts a timer. When this timer expires, it enters a new state, waiting for messages sent by first task. If it receives messages from first task while in idle state, it ignores them.

After having received 3 messages from the first task, it enters back its idle state.